# Architecture Brief: Nebula-Engine (星云引擎)

Version: 0.1 (Draft)

Status: Conceptual Stage

Author: Jabbey

Date: 2026年1月

## Project Positioning - 核心定位

### 一句话定位

Nebula-Engine(星云引擎)：**一款面向开发者的轻量级嵌入式业务规则自动化引擎。**

### 服务对象 (For Whom)

* 中小型应用的后端开发者

* 大型系统中负责处理**规则频繁变更**、需要**高度灵活性**业务模块的开发者与架构师

### 核心痛点 (Problem Statement)

Nebula-Engine 旨在解决业务系统中常见但难以优雅处理的问题：

* **选择困境**：开发者陷入“硬编码修改慢”与“重型引擎引入难”的两难选择
* **逻辑僵化**：业务判断逻辑复杂、多变、相互交叉，长期以 **if-else / hard-coded** 形式散落在核心业务流程中
* **复用性差**：相似逻辑无法抽象复用，重复开发
* **响应迟滞**：每次规则调整都需走完整开发-测试-发布流程
* **逻辑黑盒**：业务决策过程隐含在代码中，缺乏清晰的结构化表达，逐渐演变为“黑盒逻辑”

### 生态位与形态 (Niche & Form)

我们聚焦于**业务决策逻辑的编排**，而非**业务流程的管理**。

* **我们是 (What We Are)：** 业务逻辑的“胶水”与决策机。一个专注于“决策判断”的 **SDK / Library**，可无缝嵌入现有应用，用于承载和执行业务规则。
* **我们不是 (What We Are Not)：**
    * 一个重型的业务流程管理（BPM）平台;
    * 一个提供人工可视化编排的工具;
    * 一个长事务管理器;
    * 一个需要独立部署的中间件服务;

### 核心使命 (Mission)

将业务系统中**“多变、交叉、复杂”的判断逻辑**从命令式代码（Hard-coded）中剥离，转化为**声明式、可组合、可动态加载**的原子单元，实现业务逻辑与底层架构的彻底解耦。

### 核心价值 (Value Proposition)

* **研发侧 (Efficiency & Quality)：** 缓解“面条代码”，用标准化的逻辑编排替代碎片化的 `if-else`，降低业务规则变更对代码结构的侵入性，提高长期可维护性。
* **业务侧 (Agility & Transparency)：** 实现逻辑“热插拔”，规则变更无需重启服务或重新发布，缩短业务响应周期，极大地提升业务灵敏度，提升业务试错速度与市场响应能力。
* **平衡点 (Optimal Choice)：** 介于“硬编码”与“重型引擎（如 Drools）”之间，主打**极简抽象**与**低学习成本**。



## Conceptual Model - 概念模型

### **设计哲学**

Nebula-Engine 遵循 **"上下文驱动、规则编排、决策追溯"** 的设计理念，将业务决策抽象为三个清晰层次：

1. **数据层**（Context） - 承载决策的**完整状态**
2. **逻辑层**（Condition + Rule） - 定义决策的**业务规则**
3. **执行层**（Action + Strategy） - 控制决策的**执行过程**

**1. Engine (引擎)**

- **描述**：Engine 是规则评估与决策生成的运行时容器，是对外提供统一决策服务的核心入口。
- **职责**：加载`Rule(规则)`、接收`Context(上下文)`、匹配`Condition(条件)`、执行`Action(动作)`、响应`Decision(决策)`。
- **定位**：规则执行过程的**核心协调者与运行时宿主**
- **特性**：线程安全、轻量级、支持单例或多例、可观测性

**2. Context (上下文)：**

* **描述**：Context 是 Nebula-Engine 决策周期的**核心数据载体**，封装了决策所需的所有原始事实与过程状态。
* **定位**：决策原材料的“托盘”与状态存储的“工作台”
* **职责**：提供数据读取接口，并作为 `Action(动作)` 修改结果的存储介质。
* **特性**：自包含 (Self-contained)、生命周期内的一致性

**3. Condition (条件/判断器)：**

* **描述**：基于`Context(上下文)`的数据，通过 `Operator(操作符)` 构建的逻辑断言。
* **定位**：规则的“触发器”
* **职责**：用于评估当前 `Context(上下文)` 是否满足规则的触发前提。
* **约束**：其结果必须为布尔值（`true` 或 `false`）。
* **特性**： 幂等性（评估过程不应改变 `Context(上下文)` 的状态）。

**4. Action (动作/指令/执行器)：**

* **描述**：Action 表示规则命中后执行的原子能力单元。当`Condition(条件)=true`这些指令将被执行。

* **定位**：规则的“执行载体”

* **职责**：当条件满足时执行具体业务操作的**原子指令**。

* **特性**：原子性、幂等性、可配置

* **模式**：

    * Mutation (变更型)： 直接修改`Context(上下文)`里的数据（如：将订单状态设为“已折扣”）。

    - Side-Effect (副作用型)：产生外部指令（如：消息通知、审计日志）。

**5. Rule (规则/指令)：**

* **描述**：一个独立的、具名的最小业务决策单元，它描述了“在什么条件下，应当触发哪些动作意图”。
* **构成**： `Rule = Name + Condition (When) + Action (Then) + Metadata (Priority/Tag)`
* **定位**：最小逻辑闭环(如果-那么)
* **意义**：它是业务逻辑的最小原子单位，具备独立存在和被复用的价值。

**6. Decision (决策)：**

- **描述**：引擎在处理完规则后，返回给调用方的“最终报告”。
- **形态**：包含了所有被触发的规则及其对应动作的集合。记录了“哪些规则被触发、触发的时间、执行了哪些 Action、Fact 最终的状态”。
- **定位**：业务系统的“执行凭据”
- **意义**：它不仅是结果，更是决策`轨迹 (Trace)`。
- **特性**：可追溯、可度量、可调试

**7. Execution Strategy (执行策略)：**

- **定义**：定义了规则之间的**冲突仲裁机制**（如：是执行第一条命中的，还是执行所有命中的）。

- **定位**：定义规则冲突与执行方式的“仲裁者”

- **职责**：解决“冲突”

- **V1.0 预设模式**：

    - **`Fire-First`**：仅执行命中的第一条规则，适用于互斥型决策。

    - **`Fire-All`**：执行所有命中的规则，适用于叠加型逻辑。

- **演进说明**：这是对你 `Strategy` 概念的简化落地。未来可演进为可插拔的策略对象。

**8. RuleChain (规则链)：**

- **定义**：多个 `Rule(规则)` 按照特定拓扑结构（顺序、分支、循环）组成的逻辑集合。
- **定位**：业务流程的全景图
- **职责**：解决“冲顺序”
- **类型**：顺序链、分支链、并行链、循环链
- **V1.0 状态**：**Out of Scope**（**暂不引入的核心概念**）。


## Runtime Model - 运行时模型

本模型描述了 `Nebula-Engine` 从初始化到完成单次决策的完整生命周期与内部数据流向。其核心设计理念是：**单向流转、逻辑闭环、执行异步化。**

### 引擎生命周期：初始化阶段 (Initialization Phase)

此阶段旨在构建一个**高性能、线程安全**且**就绪态 (Ready-to-serve)** 的引擎实例，通常在应用启动或配置热更新时触发。

1. **实例化 (Instantiation)**
    * 应用程序根据需要，创建一个或多个 `Engine` 实例。
    * 每个实例都拥有独立的规则集和配置，都是逻辑隔离的沙箱。

2. **规则加载 (Loading)**
    * `Engine` 实例通过 **`Rule Loader` (规则加载器)**，从指定的外部源（如本地 JSON/YAML 文件、数据库或配置中心）读取原始规则定义。
3. **解析与校验 (Parsing & Validation)**
    * **`Rule Parser` (规则解析器)** 将文本定义转化为内存中结构化的、可执行的 `Rule` 对象集合，并进行静态语法校验。
4. **配置与持有 (Configuration & Holding)**
    - `Engine` 实例加载其 **`Execution Strategy` (执行策略)**（例如 `Fire-First` 或 `Fire-All`）等核心配置。
    - 引擎将所有解析后的 `Rule` 对象和配置信息保存在内部，转化为 **不可变的 Rule 快照**，完成初始化，进入待命状态，准备接收外部调用。

### 决策执行流：执行阶段 (Execution Phase)

每次 `engine.execute(context)` 均为一次**瞬时、无状态、同步**的决策过程。

1. **上下文注入（Context Ingestion）**

    - 外部业务逻辑（宿主应用）遭遇一个决策点（如用户下单、风险校验）。
    - 宿主应用收集业务数据，构造并初始化一个 `Context` 对象。
    - 宿主应用调用引擎的执行入口，如 `engine.execute(context)`，将 `Context` 注入引擎。

2. **规则评估 (Evaluation)**

    - 引擎内置的 **`Matcher` (匹配器)** 接收 `Context`，并开始遍历引擎持有的所有 `Rule`快照。
    - 针对每条 `Rule`，`Condition` 以 `Context` 为唯一数据源进行布尔评估。此过程必须是**幂等且只读**的。

    - 引擎收集所有 `Condition` 评估结果为 `true` 的规则，形成一个“**匹配集 (Matched Set)**”。

3. **冲突解决与排序 (Conflict Resolution)**

    - 根据预设的 `Execution Strategy` 和规则的优先级（Priority），对“匹配集”进行排序和筛选，产生一个最终有序的“**待执行列表 (Execution List)**”。

4. **动作触发与状态演进 (Action Execution)**

    - 引擎按照“待执行列表”的顺序，依次触发列表中每个 `Rule` 的 **`Action` (动作)**。
    - `Action` 在执行时，被允许读取和**修改 (Mutate)** `Context` 的状态。一个 `Action` 对 `Context` 的修改，可能会影响后续 `Action` 的执行上下文。
    - 状态演进 (State Evolution)
        - **Mutation 型动作**：直接修改 `Context` 中的数据，这些修改对后续执行的规则可见。
        - **Side-Effect 型动作**：在 `Decision` 中记录外部调用意图，但不直接产生外部副作用。
    - **V1.0 范围说明**：在 V1.0 中，不支持 `Action` 触发新一轮的规则匹配（即无 Agenda 循环）。执行流是单向、一次性的。

5. **决策响应 (Termination & Response)**

    - 所有“待执行列表”中的 `Action` 执行流结束（或命中 Fire-First 终止）。
    - 引擎将执行轨迹（触发规则、动作详情、`Context` 最终态）封装成一个 **`Decision` (决策)** 对象。
    - 引擎将 `Decision` 对象 **同步返回** 给宿主应用。
    - 宿主应用接收 `Decision` 对象，可以从中提取最终的计算结果，或根据其提供的“副作用型”指令，执行与外部系统的交互（如发送消息、调用API等）。

### 宿主应用职责边界 (Separation of Concerns)

**Nebula-Engine** 严格遵循“决策与执行分离”的原则：

| 维度           | 引擎职责 (Engine)                         | 宿主应用职责 (Host App)                      |
| :------------- | :---------------------------------------- | :------------------------------------------- |
| **核心关注点** | **判断“应该做什么”**                      | **执行“具体怎么做”**                         |
| **数据处理**   | 评估逻辑、修改 Context 状态、生成决策轨迹 | 收集原始数据、初始化 Context、持久化最终状态 |
| **业务行为**   | 仅记录 Side-Effect 意图                   | 执行真实的 API 调用、发送通知、触发外部事务  |
| **流程控制**   | 确保单次决策逻辑的正确性                  | 决定是否基于引擎结果发起下一轮决策调用       |


## Out of Scope - 排除范围

为确保 **Nebula-Engine V1.0** 保持轻量、可嵌入且专注于“业务决策”的核心定位，以下功能明确不包含在本项目核心职责内。任何对这些功能的依赖应由宿主应用自行实现。

### 流程与编排 (Process & Orchestration)

* **长周期流程编排 (Workflow)：** 不处理跨天、长周期、涉及人工参与的审批流（如 BPMN 规范）。引擎仅处理**瞬时 (In-memory)** 、基于数据的逻辑判定。
* **规则链触发 (Rule Chaining)：** V1.0 不支持规则间的拓扑依赖（规则链），也不支持由 `Action` 结果反向触发新一轮匹配的循环机制（Agenda Cycle）。规则在逻辑上是平等、单次触发的。

### 基础设施与持久化 (Infrastructure & Persistence)

* **数据持久化 (Persistence)：** 引擎不负责 `Context` 的持久化存储（如存入数据库）。所有的规则定义加载、Context 的快照存储，均由宿主应用调用对应的接口或外部持久化层完成。
* **分布式调度 (Scheduling)：** 引擎不具备定时触发或延迟触发规则的能力。作为一个被动调用的 **Library**，其执行时机完全由宿主应用控制。
* **分布式事务 (Transactions)：** 引擎不参与分布式事务管理（如 TCC、Saga）。若 Action 涉及外部副作用，其事务一致性由宿主应用或 Action 逻辑内部自行保证。

### 计算与性能 (Computation & Performance)

* **复杂脚本支持 (Scripting)：** Condition 仅支持基础的逻辑运算（AND/OR/NOT）与算术运算。V1.0 暂不开放复杂的自定义脚本语言嵌入（如 Groovy, JavaScript）。
* **重计算与流处理 (Heavy & Stream Computing)**：引擎专注于业务决策，不适用于大规模海量数据的窗口聚合、离线统计或高吞吐量的流式任务（如 Flink/Spark 场景）。
* **异步执行模型 (Asynchrony)：** `engine.execute()` 遵循**阻塞式同步调用**模型。引擎内部不维护异步线程池或回调机制。

### 交互与运维 (UI & Operations)

* **图形化管理 (UI/GUI)：** 引擎不提供可视化规则编辑器、规则管理后台或监控大屏。规则集统一通过标准化的结构化文本（JSON/YAML）进行配置。
* **独立服务化 (Standalone Service)：** 引擎不提供独立部署的 Server 端，不支持分布式集群协调或内置高可用（HA）机制。它是一个纯粹的**嵌入式 SDK**。
* **决策度量 (Decision Metrics)：** 引擎不内置大数据的埋点统计能力。虽然 `Decision` 对象提供追踪轨迹，但聚合分析（如“规则命中率统计”）属于宿主应用或辅助工具的范畴。

### 总结性声明

**Nebula-Engine** 有意识地规避了**流程编排、分布式调度、持久化与复杂计算**能力，以换取 **极简的计算模型、可预测的执行行为以及低侵入的嵌入式使用体验**。


## Evolution Points - 演进点

